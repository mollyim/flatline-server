// Copyright 2022 Signal Messenger, LLC
// SPDX-License-Identifier: AGPL-3.0-only

#include "crud_test_fns.h"
#include "util/util.h"

// Include the untrusted cds header that is generated
// during the build. This file is generated by calling the
// sdk tool oeedger8r against the cds.edl file.
#include "untrust/cds_u.h"
#include "proto/cdsi.h"
#include "proto/pbutil.h"
#include "aci_pni_uak_helpers/aci_pni_uak_helpers.h"
#include "ratelimit/ratelimit.h"
#include "noiseutil/noise.h"
#include "checks.h"

#include <inttypes.h>
#include <stdio.h>
#include <sys/random.h>
#include <assert.h>
#include <time.h>
#include <unistd.h>


#define ACK_REQUEST_SIZE 3

uint8_t *create_query_pb(client_request *cr, int *result_size, enclave_client_state *ecs)
{
    // size of the base stucture plus size of the arrays
    size_t workspace_size = PBUTIL_WORKSPACE_BASE(struct org_signal_cdsi_client_request_t) + cr->num_pairs * 32 + cr->num_e164s * 8;
    uint8_t *workspace = malloc(workspace_size);

    struct org_signal_cdsi_client_request_t *req = org_signal_cdsi_client_request_new(workspace, workspace_size);
    if (req == 0)
    {
        free(workspace);
        return 0;
    }
    req->aci_uak_pairs.buf_p = (uint8_t *)cr->aci_uak_pairs;
    req->aci_uak_pairs.size = cr->num_pairs * sizeof(*cr->aci_uak_pairs);
    req->new_e164s.buf_p = (uint8_t *)cr->e164s;
    req->new_e164s.size = cr->num_e164s * sizeof(uint64_t);
    if(ecs->has_token){
        req->token.buf_p = ecs->token;
        req->token.size = RATELIMIT_TOKEN_SIZE;
    }
    
    uint8_t *result = malloc(workspace_size);
    *result_size = org_signal_cdsi_client_request_encode(req, result, workspace_size);

    if (*result_size < 0)
    {
        free(result);
        result = 0;
    }

    free(workspace);
    return result;
}

uint8_t *create_ack_request(int *result_size)
{
    uint8_t workspace[128];

    struct org_signal_cdsi_client_request_t *req = org_signal_cdsi_client_request_new(workspace, sizeof(workspace));
    if (req == 0)
    {
        return 0;
    }
    req->token_ack = true;

    uint8_t *result = malloc(ACK_REQUEST_SIZE);
    *result_size = org_signal_cdsi_client_request_encode(req, result, ACK_REQUEST_SIZE);

    if (*result_size < 0)
    {
        free(result);
        result = 0;
    }
    return result;
}

uint8_t *create_set_shared_secret_req(size_t size, uint8_t *secret, int *result_size)
{
    uint8_t workspace[128];
    struct org_signal_cdsi_enclave_load_t *load_req = org_signal_cdsi_enclave_load_new(workspace, sizeof(workspace));
    if (load_req == 0)
    {
        return NULL;
    }

    load_req->shared_token_secret.buf_p = secret;
    load_req->shared_token_secret.size = size;

    uint8_t *result;
    CHECK(result = calloc(1, sizeof(workspace)));
    *result_size = org_signal_cdsi_enclave_load_encode(load_req, result, sizeof(workspace));
    if (result_size < 0)
    {
        free(result);
        return NULL;
    }
    return result;
}

int call_ratelimit(enclave_client_state *ecs, client_request req)
{
    int pb_size = 0;
    error_t err = err_SUCCESS;
    oe_result_t result;
    int retval;
    uint8_t *ct_buf = 0;
    uint8_t *pb = create_query_pb(&req, &pb_size, ecs);
    if (pb == 0)
    {
        err = err_HOST__RATELIMIT__REQUEST_PB;
        goto exit;
    }

    // now we need to encrypt it
    size_t ct_buf_size = pb_size + 32;
    CHECK(ct_buf = calloc(ct_buf_size, 1));
    memcpy(ct_buf, pb, pb_size);
    NoiseBuffer buf_inout;
    noise_buffer_set_inout(buf_inout, ct_buf, pb_size, ct_buf_size);
    if (NOISE_ERROR_NONE != noise_cipherstate_encrypt(ecs->send, &buf_inout))
        return err_HOST__RATELIMIT__ENCRYPT;

    size_t out_size = 128;
    uint8_t out[128];
    size_t actual_out_size = 0;
    uint8_t old_token_hash[32] = {0};
    uint8_t new_token_hash[32] = {0};
    size_t actual_old_token_hash_size = 0;
    size_t actual_new_token_hash_size = 0;
    size_t computed_request_size = 0;
    result = enclave_rate_limit(ecs->enclave, &retval, ecs->client_id,
                                buf_inout.size, ct_buf,
                                out_size, out, &actual_out_size,
                                sizeof(old_token_hash), old_token_hash, &actual_old_token_hash_size,
                                sizeof(new_token_hash), new_token_hash, &actual_new_token_hash_size,
                                &computed_request_size);

    if (result != OE_OK)
    {
        fprintf(
            stderr,
            "calling into enclave_rate_limit failed: result=%u (%s)\n",
            result,
            oe_result_str(result));
        err = err_HOST__RATELIMIT__CALL_ENCLAVE;
        goto exit;
    }
    if (retval != 0)
    {
        fprintf(
            stderr,
            "enclave_rate_limit failed internally: result=%u\n",
            retval);
        err = retval;
        goto exit;
    }

    // decrypt the response
    NoiseBuffer buf_out;
    noise_buffer_set_inout(buf_out, out, actual_out_size, out_size);
    int noise_err = noise_cipherstate_decrypt(ecs->recv, &buf_out);
    if (NOISE_ERROR_NONE != noise_err)
    {
        noise_perror("noise_cipherstate_decrypt", noise_err);
        err = err_HOST__RATELIMIT__DECRYPT;
    }

    // decode the response
    unsigned char rsp_workspace[256];
    struct org_signal_cdsi_client_response_t *rsp = org_signal_cdsi_client_response_new(rsp_workspace, sizeof(rsp_workspace));
    if (rsp == 0)
    {
        err = err_HOST__RATELIMIT__RESPONSE_ENCODE;
        goto exit;
    }

    int size = org_signal_cdsi_client_response_decode(rsp, out, buf_out.size);
    if (size < 0)
    {
        err = err_HOST__RATELIMIT__RESPONSE_ENCODE;
        goto exit;
    }

    // update client state
    memcpy(ecs->token, rsp->token.buf_p, rsp->token.size);
    ecs->has_token = true;
exit:
    free(pb);
    free(ct_buf);
    return err;
}

int run(enclave_client_state *ecs, size_t num_triples, e164_pni_aci_triple *triples)
{

    error_t err = err_SUCCESS;
    int pb_size = 0;
    uint8_t *ct_buf = 0;
    uint8_t *rsp_workspace = 0;

    uint8_t *pb = create_ack_request(&pb_size);
    if (pb == 0)
    {
        err = err_HOST__RUN__REQUEST_PB;
        goto exit;
    }

    oe_result_t result;
    int retval;
    // now we need to encrypt it
    size_t ct_buf_size = pb_size + 32;
    CHECK(ct_buf = calloc(ct_buf_size, 1));
    memcpy(ct_buf, pb, pb_size);

    NoiseBuffer buf_inout;
    noise_buffer_set_inout(buf_inout, ct_buf, pb_size, ct_buf_size);
    if (NOISE_ERROR_NONE != noise_cipherstate_encrypt(ecs->send, &buf_inout))
    {
        err = err_HOST__RATELIMIT__ENCRYPT;
        goto exit;
    }

    size_t out_size = num_triples * sizeof(*triples) + 32;
    uint8_t *out;
    CHECK(out = calloc(out_size, 1));
    size_t actual_out_size = 0;

    result = enclave_run(ecs->enclave, &retval, ecs->client_id,
                         0, buf_inout.size, ct_buf,
                         out_size, out, &actual_out_size);

    if (result != OE_OK)
    {
        fprintf(
            stderr,
            "calling into enclave_run failed: result=%u (%s)\n",
            result,
            oe_result_str(result));
        err = err_HOST__RUN__CALL_ENCLAVE;
        goto exit;
    }
    if (retval != 0)
    {
        fprintf(
            stderr,
            "enclave_run failed internally: result=%u\n",
            retval);
        // it's a known enclave error code
        err = retval;
        goto exit;
    }

    // decrypt the response
    NoiseBuffer buf_out;
    noise_buffer_set_inout(buf_out, out, actual_out_size, out_size);
    int noise_err = noise_cipherstate_decrypt(ecs->recv, &buf_out);
    if (NOISE_ERROR_NONE != noise_err)
    {
        noise_perror("noise_cipherstate_decrypt", noise_err);
        return err_HOST__RUN__DECRYPT;
    }

    // decode the response
    size_t rsp_workspace_size = actual_out_size + 64;
    rsp_workspace = malloc(rsp_workspace_size);
    struct org_signal_cdsi_client_response_t *rsp = org_signal_cdsi_client_response_new(rsp_workspace, rsp_workspace_size);
    if (rsp == 0)
    {
        err = err_HOST__RUN__RESPONSE_PB;
        goto exit;
    }

    int size = org_signal_cdsi_client_response_decode(rsp, out, buf_out.size);
    if (size < 0)
    {
        err = err_HOST__RUN__RESPONSE_PB;
        goto exit;
    }

    // update client state
    memcpy(triples, rsp->e164_pni_aci_triples.buf_p, rsp->e164_pni_aci_triples.size);

exit:
    free(pb);
    free(ct_buf);
    free(rsp_workspace);
    return err;
}

void report_performance(
    size_t num_tasks,
    clock_t start_clock,
    clock_t end_clock,
    struct timespec start_ts,
    struct timespec end_ts)
{
    double elapsed = (end_ts.tv_sec - start_ts.tv_sec);
    elapsed += (end_ts.tv_nsec - start_ts.tv_nsec) / 1000000000.0;
    long elapsed_clock = end_clock - start_clock;
    double elapsed_clock_micros = 1000000.0 * (double)elapsed_clock / (double)CLOCKS_PER_SEC;

    double throughput = (double)num_tasks / elapsed;
    double mean_elapsed_micros_per_task = 1000000.0 * elapsed / (double)num_tasks;
    double mean_clock_micros_per_task = elapsed_clock_micros / (double)num_tasks;

    printf("num tasks: %lu elapsed time: %lf\nthroughput: %lf mean elapsed micros per task: %lf  mean CPU micros per task: %lf\n",
           num_tasks,
           elapsed,
           throughput,
           mean_elapsed_micros_per_task,
           mean_clock_micros_per_task);
}

uint8_t *create_query_pb_from_records(size_t num_records, signal_user_record *records, int *result_size, enclave_client_state *ecs)
{
    size_t workspace_size = num_records * (8 + 40) + 1024; // 40 bytes for triples, 8 bytes for e164s
    uint8_t *workspace = malloc(workspace_size);
    uint64_t *e164s;
    CHECK(e164s = calloc(num_records, sizeof(*e164s)));
    uint64_t *aci_uak_pairs;
    CHECK(aci_uak_pairs = calloc(num_records, 4 * sizeof(uint64_t)));

    for (size_t i = 0; i < num_records; ++i)
    {
        e164s[i] = records[i].e164;
        aci_uak_pairs[4 * i] = records[i].aci[0];
        aci_uak_pairs[4 * i + 1] = records[i].aci[1];
        aci_uak_pairs[4 * i + 2] = records[i].uak[0];
        aci_uak_pairs[4 * i + 3] = records[i].uak[1];
    }

    struct org_signal_cdsi_client_request_t *req = org_signal_cdsi_client_request_new(workspace, workspace_size);
    req->aci_uak_pairs.buf_p = (uint8_t *)aci_uak_pairs;
    req->aci_uak_pairs.size = num_records * 4 * sizeof(uint64_t);
    req->new_e164s.buf_p = (uint8_t *)e164s;
    req->new_e164s.size = num_records * sizeof(uint64_t);
    req->prev_e164s.buf_p = 0;
    req->prev_e164s.size = 0;
    req->discard_e164s.buf_p = 0;
    req->discard_e164s.size = 0;
    req->token.buf_p = ecs->token;
    req->token.size = sizeof(ecs->token);

    uint8_t *result = malloc(workspace_size);
    *result_size = org_signal_cdsi_client_request_encode(req, result, workspace_size);

    free(e164s);
    free(aci_uak_pairs);
    free(workspace);
    return result;
}

int test_data_load(oe_enclave_t *enclave, size_t num_records, size_t num_sample_batches, size_t batch_size, signal_user_record sample_record_batches[])
{
    int retval = 0;
    error_t err = err_SUCCESS;
    uint8_t *workspace = 0;
    uint8_t *encoded = 0;
    signal_user_record *data = 0;

    size_t num_records_to_add = num_records;
    size_t records_per_block = 5000;
    size_t num_blocks = num_records_to_add / records_per_block;

    if (batch_size > records_per_block)
    {
        return err_HOST__LOADPB__TOO_MANY_SAMPLES;
    }

    CHECK(data = calloc(records_per_block, sizeof *data));
    printf("adding %lu blocks for %lu total records\n", num_blocks, num_records_to_add);

    size_t workspace_size = 2 * records_per_block * 64;
    workspace = malloc(workspace_size);
    size_t encoded_size = records_per_block * 56 + 32;
    encoded = malloc(encoded_size);
    struct org_signal_cdsi_enclave_load_t *load_req = org_signal_cdsi_enclave_load_new(workspace, workspace_size);
    if (load_req == 0)
    {
        err = err_HOST__LOADPB__REQUEST_PB;
        goto exit;
    }

    size_t sample_stride = (records_per_block * num_blocks) / num_sample_batches;
    size_t batch_num = 0;
    printf("sample_stride: %zu\n", sample_stride);
    // clock_t start = clock();
    struct timespec begin, finish;
    clock_gettime(CLOCK_MONOTONIC, &begin);
    clock_t start_clock = clock();
    for (size_t block = 0; block < num_blocks; ++block)
    {

        memset(data, 0, records_per_block * sizeof *data);
        for (size_t i = 0; i < records_per_block; ++i)
        {
            uint64_t buf[7];
            getentropy(buf, sizeof buf);
            data[i].e164 = buf[0];
            data[i].aci[0] = buf[1];
            data[i].aci[1] = buf[2];
            data[i].pni[0] = buf[3];
            data[i].pni[1] = buf[4];
            data[i].uak[0] = buf[5];
            data[i].uak[1] = buf[6];
        }
        while (batch_num * sample_stride >= block * records_per_block && batch_num * sample_stride < (block + 1) * records_per_block - batch_size)
        {
            size_t block_offset = (batch_num * sample_stride) % records_per_block;
            printf("sampling batch %lu/%lu\n", batch_num, num_sample_batches);
            memcpy(sample_record_batches + batch_num * batch_size, data + block_offset, batch_size * sizeof(*sample_record_batches));
            batch_num++;
        }
        if (batch_num * sample_stride < block * records_per_block)
        {
            // just force it into the block instead of dealing with wraparound
            size_t block_offset = records_per_block - batch_size;
            printf("sampling batch %lu/%lu\n", batch_num, num_sample_batches);
            memcpy(sample_record_batches + batch_num * batch_size, data + block_offset, batch_size * sizeof(*sample_record_batches));
            batch_num++;
        }

        load_req->clear_all = false;
        load_req->e164_aci_pni_uak_tuples.size = records_per_block * sizeof(*data);
        load_req->e164_aci_pni_uak_tuples.buf_p = (uint8_t *)data;
        load_req->shared_token_secret.size = 0;
        load_req->shared_token_secret.buf_p = 0;

        int len = org_signal_cdsi_enclave_load_encode(load_req, encoded, encoded_size);
        if (len < 0)
        {
            err = err_HOST__LOADPB__REQUEST_PB;
            goto exit;
        }
        // printf("encoded request. encoded size: %lu array size: %lu\n", len, load_req->e164_aci_pni_uak_tuples.size);
        enclave_load_pb(enclave, &retval, len, encoded);
        if (retval != 0)
        {
            printf("load call failed with code %d\n", retval);
            err = retval;
            goto exit;
        }
    }

    clock_gettime(CLOCK_MONOTONIC, &finish);
    clock_t end_clock = clock();

    printf("DATA LOAD PERFORMANCE\n--------------------------\n");
    report_performance(num_records_to_add, start_clock, end_clock, begin, finish);
    printf("--------------------------\n");

exit:
    free(data);
    free(workspace);
    free(encoded);
    return err;
}

void check_queryhit_pb_result(size_t pb_size, uint8_t *pb, size_t num_records, signal_user_record data[])
{
    size_t workspace_size = pb_size + 1024;
    uint8_t *workspace = malloc(workspace_size);

    fprintf(stderr, "create proto obj\n");
    struct org_signal_cdsi_client_response_t *rsp = org_signal_cdsi_client_response_new(workspace, workspace_size);
    assert(rsp != 0);

    fprintf(stderr, "decode\n");
    int size = org_signal_cdsi_client_response_decode(rsp, pb, 20004);
    fprintf(stderr, "pb response size: %d (result_size: %lu)\n", size, workspace_size);
    assert(size >= 0);

    e164_pni_aci_triple *triples = (e164_pni_aci_triple *)rsp->e164_pni_aci_triples.buf_p;
    assert(rsp->e164_pni_aci_triples.size == num_records * sizeof(*triples));

    // we have the triples, now for each record check that it is present in the result
    for (size_t i = 0; i < num_records; ++i)
    {
        bool found = false;
        for (size_t j = 0; j < num_records; ++j)
        {
            if (triples[j].e164 == data[i].e164)
            {
                found = true;
                assert(triples[j].aci[0] == data[i].aci[0]);
                assert(triples[j].aci[1] == data[i].aci[1]);
                assert(triples[j].pni[0] == data[i].pni[0]);
                assert(triples[j].pni[1] == data[i].pni[1]);
            }
        }
        assert(found);
    }
    printf("queryhit result passed validation\n");
    free(workspace);
}

error_t execute_query(oe_enclave_t *enclave, size_t batch_size, u64 e164s[], e164_pni_aci_triple triples_to_retrieve[], bool simulate) {
    error_t err = err_SUCCESS;
    int retval = err_SUCCESS;

    uint64_t client_id;
    uint8_t ereport[32 << 10];
    size_t ereport_size = 0;
    OPEN_ENCLAVE_CALL_TEST_ERR(enclave_new_client(enclave, &retval, &client_id, sizeof(ereport), ereport, &ereport_size));
    ENCLAVE_TEST_ERR(retval);
    fprintf(stderr, "got new client %" PRIu64 "\n", client_id);

    enclave_client_state ecs = {.client_id = client_id, .enclave = enclave, .token = {0}};

    uint8_t pubkey[NOISE_KEY_SIZE];
    ENCLAVE_TEST_ERR(extract_public_key(ereport_size, ereport, pubkey));
    ENCLAVE_TEST_ERR(perform_handshake(&ecs, simulate, pubkey));

    fprintf(stderr, "finished handshake\n");

    client_request req = {.num_e164s = batch_size, .e164s = e164s};
    for(size_t i = 0; i < batch_size; ++i) {
        TEST_LOG("%lu", req.e164s[i]);
    }

    RETURN_IF_ERROR(call_ratelimit(&ecs, req));
    ENCLAVE_TEST_ERR(run(&ecs, req.num_e164s, triples_to_retrieve));

    return err;
}

int run_query_batch(oe_enclave_t *enclave, size_t batch_size, u64 e164s[], uint64_t *elapsed_micros, bool simulate)
{
    
    // start timer
    struct timespec begin, finish;
    clock_gettime(CLOCK_MONOTONIC, &begin);
    clock_t start_clock = clock();

    // run query
    int retval = 0;
    e164_pni_aci_triple* triples;
    CHECK(triples = calloc(batch_size, sizeof(*triples)));
    RETURN_IF_ERROR(execute_query(enclave, batch_size, e164s, triples, simulate));
    if (retval != 0)
    {
        printf("query call failed with code %d\n", retval);
        return retval;
    }
    // stop timer
    clock_gettime(CLOCK_MONOTONIC, &finish);
    clock_t stop_clock = clock();

    *elapsed_micros = stop_clock - start_clock;
    *elapsed_micros = (finish.tv_sec - begin.tv_sec) * 1000000 + (finish.tv_nsec - begin.tv_nsec) / 1000;

    
    free(triples);
    return 0;
}

error_t set_ratelimit_secret(oe_enclave_t *enclave, size_t size, uint8_t *secret)
{
    int pb_size = 0;
    uint8_t *pb = create_set_shared_secret_req(size, secret, &pb_size);
    if (!pb)
    {
        return err_HOST__LOADPB__REQUEST_PB;
    }

    int oe_result = 0;
    int enclave_retval = err_SUCCESS;
    oe_result = enclave_load_pb(enclave, &enclave_retval, pb_size, pb);
    if (oe_result != 0)
    {
        free(pb);
        return err_HOST__LOADPB__ENCLAVE_CALL;
    }
    if (enclave_retval != 0)
    {
        return enclave_retval;
    }
    return err_SUCCESS;
}
